package com.expensemanager.app.ui.merchant

import android.content.Context
import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import com.expensemanager.app.data.repository.ExpenseRepository
import com.expensemanager.app.data.entities.TransactionEntity
import org.json.JSONObject
import javax.inject.Inject

@HiltViewModel
class MerchantTransactionsViewModel @Inject constructor(
    @ApplicationContext private val context: Context,
    private val repository: ExpenseRepository
) : ViewModel() {

    companion object {
        private const val TAG = "MerchantTransactionsVM"
    }

    // UI State
    private val _uiState = MutableStateFlow(MerchantTransactionsUiState())
    val uiState: StateFlow<MerchantTransactionsUiState> = _uiState.asStateFlow()

    // Events
    private val _events = MutableStateFlow<MerchantTransactionsEvent?>(null)
    val events: StateFlow<MerchantTransactionsEvent?> = _events.asStateFlow()

    fun loadMerchantTransactions(merchantName: String) {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(isLoading = true, error = null)
                
                Log.d(TAG, "Loading transactions for merchant: $merchantName")
                
                // Get all transactions for this merchant
                val transactions = repository.searchTransactions(merchantName.lowercase(), 1000)
                    .filter { it.normalizedMerchant.contains(merchantName.lowercase()) || 
                             it.rawMerchant.contains(merchantName, ignoreCase = true) }
                
                Log.d(TAG, "Found ${transactions.size} transactions for $merchantName")
                
                // Calculate totals
                val totalAmount = transactions.sumOf { it.amount }
                val totalCount = transactions.size
                val sortedTransactions = transactions.sortedByDescending { it.transactionDate }
                
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    transactions = sortedTransactions,
                    totalAmount = totalAmount,
                    totalCount = totalCount,
                    merchantName = merchantName
                )
                
            } catch (e: Exception) {
                Log.e(TAG, "Error loading merchant transactions", e)
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Error loading transactions: ${e.message}"
                )
            }
        }
    }

    fun loadInclusionState(merchantName: String) {
        val prefs = context.getSharedPreferences("expense_calculations", Context.MODE_PRIVATE)
        val inclusionStatesJson = prefs.getString("group_inclusion_states", null)
        
        Log.d(TAG, "üîç Loading inclusion state for '$merchantName'")
        Log.d(TAG, "üîç Inclusion states JSON: $inclusionStatesJson")
        
        var isIncluded = true // Default to included
        
        if (inclusionStatesJson != null) {
            try {
                val inclusionStates = JSONObject(inclusionStatesJson)
                
                // Debug: Log all keys in the inclusion states
                val keys = mutableListOf<String>()
                inclusionStates.keys().forEach { key -> keys.add(key) }
                Log.d(TAG, "üîç All keys in preferences: $keys")
                
                if (inclusionStates.has(merchantName)) {
                    isIncluded = inclusionStates.getBoolean(merchantName)
                    Log.d(TAG, "üîç Found '$merchantName' in preferences: $isIncluded")
                } else {
                    Log.d(TAG, "üîç '$merchantName' NOT found in preferences, defaulting to included")
                }
            } catch (e: Exception) {
                Log.w(TAG, "Error loading inclusion state", e)
            }
        } else {
            Log.d(TAG, "üîç No inclusion states JSON found, defaulting to included")
        }
        
        _uiState.value = _uiState.value.copy(isIncludedInExpense = isIncluded)
    }

    fun updateInclusionState(merchantName: String, isIncluded: Boolean) {
        viewModelScope.launch {
            try {
                // Save to SharedPreferences
                val prefs = context.getSharedPreferences("expense_calculations", Context.MODE_PRIVATE)
                val inclusionStatesJson = prefs.getString("group_inclusion_states", null)
                
                val inclusionStates = if (inclusionStatesJson != null) {
                    JSONObject(inclusionStatesJson)
                } else {
                    JSONObject()
                }
                
                inclusionStates.put(merchantName, isIncluded)
                
                prefs.edit()
                    .putString("group_inclusion_states", inclusionStates.toString())
                    .apply()
                
                Log.d(TAG, "üîç Updated inclusion state for '$merchantName': $isIncluded")
                Log.d(TAG, "üîç Full inclusion states JSON: ${inclusionStates.toString()}")
                
                // Debug: Log all keys in the inclusion states
                val keys = mutableListOf<String>()
                inclusionStates.keys().forEach { key -> keys.add(key) }
                Log.d(TAG, "üîç All merchant keys in preferences: $keys")
                
                // FIXED: Send broadcast to notify Dashboard and other screens about inclusion state change
                val totalIncluded = inclusionStates.keys().asSequence().count { key ->
                    inclusionStates.getBoolean(key)
                }
                val intent = android.content.Intent("com.expensemanager.INCLUSION_STATE_CHANGED").apply {
                    putExtra("included_count", totalIncluded)
                    putExtra("total_amount", 0.0) // Could calculate actual amount if needed
                    putExtra("merchant_name", merchantName)
                    putExtra("is_included", isIncluded)
                }
                context.sendBroadcast(intent)
                Log.d(TAG, "üì° Broadcast sent for inclusion state change: $merchantName = $isIncluded")
                
                _uiState.value = _uiState.value.copy(isIncludedInExpense = isIncluded)
                
                _events.value = MerchantTransactionsEvent.ShowMessage(
                    if (isIncluded) "‚úÖ $merchantName included in expense calculations"
                    else "‚ùå $merchantName excluded from expense calculations"
                )
                
            } catch (e: Exception) {
                Log.e(TAG, "Error updating inclusion state", e)
                _events.value = MerchantTransactionsEvent.ShowError("Error updating inclusion state")
            }
        }
    }

    fun clearEvent() {
        _events.value = null
    }
}

data class MerchantTransactionsUiState(
    val isLoading: Boolean = false,
    val transactions: List<TransactionEntity> = emptyList(),
    val totalAmount: Double = 0.0,
    val totalCount: Int = 0,
    val merchantName: String = "",
    val isIncludedInExpense: Boolean = true,
    val error: String? = null
)

sealed class MerchantTransactionsEvent {
    data class ShowMessage(val message: String) : MerchantTransactionsEvent()
    data class ShowError(val error: String) : MerchantTransactionsEvent()
}